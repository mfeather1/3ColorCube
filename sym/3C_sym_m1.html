<!doctype html>
<html>
<head>
 <title> 3-Color Cube Symmetry </title>
 <meta name="author" content="Michael Feather">
 <meta name="robots" content="nofollow">
 <meta name=viewport content="width=device-width, initial-scale=1">
 <link rel=icon href=../mini_cube.png type=image/png>
 <script src=rch.js></script>
 <script src=../rclib.js></script>
 <script src=symlib.js></script>
 <style>
  table { border-collapse: collapse; }
  td { text-align: right; padding: 4px 10px 4px; }
  p { text-align: justify; margin-left: 10%; margin-right: 10%; }
 </style>
</head>
<body>
<center>
<font size=+2>3-Color Cube Symmetry</font>
<br>
<p> This program takes a while to run (3 minutes on 3.7 Ghz processor)
so here are the results from a previous run which can be compared to the
counts <a target=_blank href="http://forum.cubeman.org/?q=node/view/248">here</a>.
To actually run the counts, press the button below the table.</p>
<table border=1>
 <tr><td><b>Mins</b></td><td><b>Syms</b></td><td><b>Configs</b></td></tr>
 <tr><td>226325259954</td><td>48</td><td>10863612477792</td></tr>
 <tr><td>     5982162</td><td>24</td><td>     143571888</td></tr>
 <tr><td>        8566</td><td>16</td><td>        137056</td></tr>
 <tr><td>        8086</td><td>12</td><td>         97032</td></tr>
 <tr><td>         352</td><td> 8</td><td>          2816</td></tr>
 <tr><td>         222</td><td> 6</td><td>          1332</td></tr>
 <tr><td>           6</td><td> 4</td><td>            24</td></tr>
 <tr><td>          14</td><td> 3</td><td>            42</td></tr>
 <tr><td>           8</td><td> 2</td><td>            16</td></tr>
 <tr><td>           2</td><td> 1</td><td>             2</td></tr>
 <tr><td><b>226331259372</b></td><td></td><td><b>10863756288000</b></td></tr>
 <tr><td colspan=3 style=text-align:center>Ratio = 47.9994</td></tr>
</table>
<br>
<button onclick=run_counts()>Run Counts</button>
<br><br>
<div id=status></div>
<script>document.write('<a href=javascript:history.go(-1)>Back</a>')</script>
<br><br>
<script>
"use strict";

var ep_sym = new Uint16Array(E_PRM * CUBE_SYM);     //  3 MB
var epta = new Int8Array(E_PRM * E_TWIST);          // 68 MB
var count1 = new Int32Array(24 * C_PRM * C_TWIST);  // 14 MB
var count2 = new Int32Array(49);

// EPT_SYM_48_MINS is the number of EPT mins that have 48 unique symmetries,
// this value is generated by ept_sym.html

var EPT_SYM_48_MINS = 1474839;

function run_counts() {
  document.getElementById('status').innerHTML = 'Counts are running<br><br>';
  setTimeout(main, 100);
}

function main() {
  var time0 = Date.now();
  init();
  counts();
  rpt2(EPT_SYM_48_MINS*C_PRM_TW, 4);
  var time1 = ((Date.now()-time0)/1000).toFixed(2);
  document.getElementById('status').innerHTML +=
    '<br>Run Time: ' + time1 + '<br><br>';
}

function counts() {
  // use array ept_min_ops for the list of 7331 EPT configs that do not have
  // 48 unique symmetries (list is reduced by symmetry, full size is 170928)
  for (var i=0; i < N_EPT_MIN_OPS; i++) {
    var ep = ept_min_ops[i*27];
    var et = ept_min_ops[i*27+1];
    var n = fill_epta(ep, et);
    clear_count1(n);
    do_cpt_sym(ep, et);
    cpt_counts(n);
  }
}

function fill_epta(ep, et) {
  var n = 1;
  epta[ep*E_TWIST + et] = 0;
  for (var op=1; op < CUBE_SYM; op++) {
    var epsym = ep_sym[ep*CUBE_SYM + op];
    var etsym = get_etsym(ep, et, op);
    if (epta[epsym*E_TWIST + etsym] == -1)
      epta[epsym*E_TWIST + etsym] = n++;
  }
  return n;
}

function clear_count1(n) {
  for (var i=0; i < n; i++)
    for (var cp=0; cp < C_PRM; cp++)
      for(var ct=0; ct < C_TWIST; ct++)
        count1[i*C_PRM_TW + cp*C_TWIST + ct] = 0;
}

function do_cpt_sym(ep, et) {
  var epto = new Int8Array(CUBE_SYM);
  for (var op=1; op < CUBE_SYM; op++) {
    var epsym = ep_sym[ep*CUBE_SYM + op];
    var etsym = get_etsym(ep, et, op);
    epto[op] =  epta[epsym*E_TWIST + etsym];
  }
  for (var cp=0; cp < C_PRM; cp++) {
    for(var ct=0; ct < C_TWIST; ct++) {
      if (count1[cp*C_TWIST + ct] == 0) {
        var cpt = cp*C_TWIST + ct;
        count1[cpt] = cpt;
        for (var op=1; op < CUBE_SYM; op++) {
          var cpsym = cp_sym[cp*CUBE_SYM + op];
          if (CT_SYM_METHOD == 3)
            var ctsym = get_ctsym(cpsym, ct, op);
          else
            var ctsym = get_ctsym(cpt, op);
          count1[epto[op]*C_PRM_TW + cpsym*C_TWIST + ctsym] = cpt;
        }
      }
    }
  }
}

function cpt_counts(n) {
  var cpta = new Int8Array(C_PRM_TW);
  for (var i=0; i < n; i++)
    for (var cp=0; cp < C_PRM; cp++)
      for (var ct=0; ct < C_TWIST; ct++)
        cpta[count1[i*C_PRM_TW + cp*C_TWIST + ct]]++;
  for (var i=0; i < C_PRM_TW; i++)
    if (cpta[i] != 0)
      count2[cpta[i]]++;
}

function init() {
  if (ET_SYM_METHOD == 1)
    get_etsym = get_etsym_m1;
  else if (ET_SYM_METHOD == 2)
    get_etsym = get_etsym_m2;
  else
    get_etsym = get_etsym_m3;
  init2();
  set_colors_3c(0, 1, 2);
  init_map(map, sym_op_FR, sym_op_UR, reflect);
  populate_op_tables();
  populate_ep_sym();
  populate_et_sym();
  populate_ep_min();
  populate_ept_min_op();
  populate_cp_sym();
  if (CT_SYM_METHOD == 1) {
    populate_cpt_sym();
    get_ctsym = get_ctsym_m1;
  }
  else if (CT_SYM_METHOD == 2) {
    populate_op_tables();
    populate_cpt_min();
    populate_cpt_sym2();
    get_ctsym = get_ctsym_m2;
  }
  else if (CT_SYM_METHOD == 3) {
    populate_ct_sym();
    update_ct_sym();
    get_ctsym = get_ctsym_m3;
  }
  for (var ep=0; ep < E_PRM; ep++)
    for (var et=0; et < E_TWIST; et++)
      epta[ep*E_TWIST + et] = -1;
}

</script>
</center>
</body>
